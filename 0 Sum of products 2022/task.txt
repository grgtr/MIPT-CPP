

Цель этой задачи — научиться работать с аргументами командной строки, а также с указателями и динамическим выделением памяти вручную.

В этой задаче нельзя пользоваться никакими классами и функциями из стандартной библиотеки, кроме ввода/вывода в поток (cin, cout). Все выделения памяти надо делать вручную, использовать std::vector и ему подобные контейнеры нельзя.

Даны k массивов целых чисел, чьи размеры равны соответственно n1, n2,… , nk. Обозначим данные массивы за a1,… , ak. Ваша задача — посчитать и вывести сумму произведений вида a1[i1]⋅…⋅ ak[ik] по всевозможным кортежам попарно различных индексов (i1,… , ik), где каждый индекс лежит в соответствующих пределах.

Ваша программа должна использовать O(k+n1+… +nk) памяти. Выделять память «с запасом, чтоб точно хватило» нельзя.

Важно! В качестве компилятора необходимо выбирать make GCC C++17, в противном случае вы не сможете получить ОК по задаче (make нужен для того, чтобы тестирующая система могла запустить вашу программу с аргументами командной строки!).
Формат ввода

Числа n1,… , nk вводятся в виде параметров командной строки. После чего через стандартный поток ввода вводятся элементы массивов один за другим, то есть сначала все элементы первого массива, затем все элементы второго, и т.д.

Например, ваша программа может быть вызвана так: ./a.out 7 2 4 8 9

Это будет означать, что k = 5, а размеры массивов равны соответственно a1 = 7,… , a5 = 9.

Формат вывода

Выведите единственно число — ответ на задачу.
Примечания

    Гарантируется, что все элементы массивов влезают в int, а ответ влезает в long long.

    Наличие в условии задачи 1-индексации не означает, что в вашей программе индексация должна идти с 1 :)

    Не пытайтесь придумать какой-то умный алгоритм, избежав перебора. Это NP-трудная задача (даже хуже, чем просто NP-трудная, но забейте). Цель — аккуратно и правильно написать перебор, корректно выделив и освободив все динамические массивы.

